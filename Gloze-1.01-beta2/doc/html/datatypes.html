<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Gloze: Datatypes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="datatypes">Datatypes </a></h1><p>The RDF semantics recommendation identifies a subset of XML schema datatypes that are suitable for use in RDF. The following XML datatypes may be used in RDF typed literals. For example, an xs:string "foobar", would be represented in RDF (N3) as "foobar"^^&lt;<a href="http://www.w3.org/2001/XMLSchema#string">http://www.w3.org/2001/XMLSchema#string</a>&gt;.</p>
<ul>
<li>xs:string</li>
<li>xs:boolean</li>
<li>xs:decimal</li>
<li>xs:float</li>
<li>xs:double</li>
<li>xs:dateTime</li>
<li>xs:time</li>
<li>xs:date</li>
<li>xs:gYearMonth</li>
<li>xs:gYear</li>
<li>xs:gMonthDay</li>
<li>xs:gDay</li>
<li>xs:gMonth</li>
<li>xs:hexBinary</li>
<li>xs:base64Binary</li>
<li>xs:anyURI</li>
<li>xs:normalizedString</li>
<li>xs:token</li>
<li>xs:language</li>
<li>xs:NMTOKEN</li>
<li>xs:Name</li>
<li>xs:NCName</li>
<li>xs:integer</li>
<li>xs:nonPositiveInteger</li>
<li>xs:negativeInteger</li>
<li>xs:long</li>
<li>xs:int</li>
<li>xs:short</li>
<li>xs:byte</li>
<li>xs:nonNegativeInteger</li>
<li>xs:unsignedLong</li>
<li>xs:unsignedInt</li>
<li>xs:unsignedShort</li>
<li>xs:unsignedByte</li>
<li>xs:positiveInteger</li>
</ul>
<p><a class="el" href="elementstring.html">datatype example</a></p>
<p>The exceptions include:</p>
<ul>
<li>xs:anySimpleType</li>
<li>xs:duration</li>
<li>xs:ENTITY</li>
<li>xs:ENTITIES</li>
<li>xs:ID</li>
<li>xs:IDREF</li>
<li>xs:IDREFS</li>
<li>xs:NMTOKENS</li>
<li>xs:NOTATION</li>
<li>xs:QName</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">http://www.w3.org/TR/2004/REC-rdf-mt-20040210/</a> <a href="http://www.w3.org/TR/xpath-functions/">http://www.w3.org/TR/xpath-functions/</a> <a href="http://www.w3.org/TR/swbp-xsch-datatypes/">http://www.w3.org/TR/swbp-xsch-datatypes/</a></dd></dl>
<p>The following sections explore work-arounds for all of these datatypes.</p>
<h2><a class="anchor" id="anySimpleType">
The mother of all simple types (xs:anySimpleType)</a></h2>
<p>This type is the base of all simple types with an unconstrained lexical space. User defined restrictions of xs:anySimpleType are not allowed. Indeed, users are generally advised to steer clear of it altogether.</p>
<p>Yet, both elements and attributes may be defined to be of type xs:anySimpleType (it's also the default type for attributes). Also, anySimpleType may be used as the base of a simpleContent extension.</p>
<p>Thinking about an RDF savvy mapping, it occupies a similar place in the pantheon of classes as rdfs:Literal, the superclass of all literals including datatypes. Thus any XML content of type xs:anySimpleType is mapped to an rdfs:Literal.</p>
<p><a class="el" href="attributeanysimpletype.html">anySimpleType example</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.w3.org/2001/05/xmlschema-rec-comments#pfiS4SanySimpleType">http://www.w3.org/2001/05/xmlschema-rec-comments#pfiS4SanySimpleType</a> <a href="http://lists.w3.org/Archives/Member/w3c-xml-schema-ig/2002Jan/0065.html">http://lists.w3.org/Archives/Member/w3c-xml-schema-ig/2002Jan/0065.html</a></dd></dl>
<h2><a class="anchor" id="duration">
Duration (xs:duration)</a></h2>
<p>The problem with xs:duration is that there's no well-defined total ordering over it's value space (durations are partially ordered). The problem stems from there being an indeterminate number of days in a month. The recommended solution used by <a class="el" href="classcom_1_1hp_1_1gloze_1_1_gloze.html">Gloze</a> is to distill a single period such as "P7Y2M26DT14H18M10S" (years, months, days, hours, minutes, seconds) into separate xs:yearMonthDuration "P7Y2M" (years, months) and xs:dayTimeDuration "P26DT14H18M10S" (days, hours, minutes, seconds) datatypes. The reverse process, is equivalent to adding the these values, both of which are subclasses of duration. When adding two durations, each component is added independently, ignoring - in particular - any carry from days to months.</p>
<p><a class="el" href="elementduration.html">duration example</a></p>
<h2><a class="anchor" id="entity">
Entities (xs:ENTITY)</a></h2>
<p>An XML schema ENTITY allows the substitution of common text values or balanced mark-up defined as XML entities. ENTITY values must match an entity name declared in the DTD of the instance document. The value space of unexpanded entities is scoped to the instance document it appears in. For the XML to RDF mapping, internally defined entities are therefore expanded. As they may include balanced mark-up, an expanded entity can be described as an RDF XMLLiteral. There is currently no reverse mapping due to technical issues in editing document type declarations in level 2 DOM.</p>
<p><a class="el" href="elemententity.html">entity example</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://jena.sourceforge.net/how-to/typedLiterals.html#xsd">http://jena.sourceforge.net/how-to/typedLiterals.html#xsd</a></dd></dl>
<h2><a class="anchor" id="xsid">
Identity datatypes (xs:ID, xs:IDREF)</a></h2>
<p>An element is considered to have an ID if it has an attribute of type ID, or if the type of the element itself is an ID.</p>
<p>IDs have no distinguishing features looking at the XML alone, they look like ordinary content. We look to the XML schema which will identify the datatype as xml schema ID. The ID is associated with the enclosing element, and that element can have at most one ID.</p>
<p>XML IDs are defined to have document scope, such that a given ID must be unique within a single document and that each ID reference should have a corresponding ID within the same document. One advantage of the mapping into RDF is that a single RDF model may contain descriptions of multiple documents. We have ensure that we preserve the global uniqueness of identifiers, and do not lose the correlation between IDs and their references when moving to this global context. An identifier of type ID can be transformed into a URI by treating it as a fragment identifier relative to the document base.</p>
<p>For example, a base <code><a href="http://example.org/base">http://example.org/base</a></code> an XML ID "foobar" combine to give the URI, <code><a href="http://example.org/base#foobar">http://example.org/base#foobar</a></code> .</p>
<p>Properties of type ID will disappear, as these simply define the URI of the identified resource. A corresponding reference to this resource with an IDREF is similarly expanded into a URI reference.</p>
<p><a class="el" href="elementidentity.html">identity example</a></p>
<h2><a class="anchor" id="notation">
Notation (xs:NOTATION)</a></h2>
<p>NOTATIONs are restricted to QNames declared in the schema. For the purposes of RDF mapping they are subject to the same rules as QNames. The target namespace and notation name are expanded to give an absolute URI for the notation resource.</p>
<p><a class="el" href="attributenotation.html">notation example</a></p>
<h2><a class="anchor" id="qNames">
Qualified Names (xs:QName)</a></h2>
<p>QNames define the space of (optionally) qualified local names. The scope of an XML namespace prefix includes the element it is defined in and its children (subject to shadowing). This lexical scoping doesn't translate directly into RDF where everything has global scope. However, the expanded QName is a URI, so it may be translated into an object reference, though typically we have no knowledge of the type of object referred to. This URI becomes associated with a resource.</p>
<p>For example, given a namespace prefix 'eg' defined as "http://example.org" the QName "eg:foobar" would be expanded to give the URI, <code><a href="http://example.org#foobar">http://example.org#foobar</a></code> .</p>
<p><a class="el" href="elementqname.html">QName example</a></p>
<h2><a class="anchor" id="listTypes">
List types (xs:IDREFS, xs:ENTITIES, xs:NMTOKENS)</a></h2>
<p>Although list types are treated as simple in XML schema, they are not recommended for use in RDF. Instead, we construct an rdf:list of the corresponding non-list type (xs:IDREF, xs:ENTITY, xs:NMTOKEN).</p>
<p><a class="el" href="elementidrefs.html">IDREFS example</a> </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Oct 28 15:42:50 2009 for Gloze by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
